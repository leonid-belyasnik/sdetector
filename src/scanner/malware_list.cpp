#include "malware_list.h"
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <vector>
#include <memory>

using namespace T1;

namespace {

	void split(std::vector<std::string> &v_str, const std::string &str, const char ch)
	{
		std::string sub;
		std::string::size_type pos = 0;
		std::string::size_type old_pos = 0;
		bool flag = true;

		while (flag)
		{
			pos = str.find_first_of(ch, pos);
			if (pos == std::string::npos)
			{
				flag = false;
				pos = str.size();
			}
			sub = str.substr(old_pos, pos - old_pos);  // Disregard the '.'
			v_str.push_back(sub);
			old_pos = ++pos;
		}
	}

	int hex2raw(const std::string& hexstr, unsigned char *outdata, int outsize)
	{
		if (!outdata)
			return -1;

		std::string hex = hexstr;
		hex.erase(std::remove(hex.begin(), hex.end(), ' '), hex.end());

		std::stringstream ss;
		int offset = 0;
		int i = 0;
		while ((size_t)offset < hex.length())
		{
			if (i == outsize)
			{
				return -2;
			}
			uint32_t buffer;

			ss << std::hex << hex.substr(offset, 2);
			ss >> std::hex >> buffer;

			outdata[i] = static_cast<unsigned char>(buffer);

			offset += 2;
			i++;

			ss.str(std::string());
			ss.clear();
		}

		return i;
	}
}

bool MalwareList::is_empty(void) const
{
	return m_box.empty();
}

bool MalwareList::is_exists(const char* filename) const
{
	if (!filename)
		return false;

	std::ifstream conffile;
	conffile.open(filename, std::ios::in);
	bool res = conffile.is_open();
	conffile.close();
	return res;
}

int MalwareList::load(const char* filename)
{
	if (!filename)
		return -1;

	std::ifstream mwfile;
	mwfile.open(filename, std::ios::in);
	if (!mwfile.is_open())
		return -1; 

	m_box.clear();
	std::string line;
	std::string hextrack;
	std::vector<std::string> v_str;
	int res = 0;
	while (std::getline(mwfile, line))
	{
		if (line.empty())
			continue;

		if (line[0] == '#')
			continue;

		v_str.clear();
		split(v_str, line, '.');
		for (auto iter = v_str.begin();; ++iter)
		{
			if (iter == v_str.begin())
			{
				hextrack = *iter;
				continue;
			}
			std::string guid = *iter;
			add(guid, hextrack);
			res++;
			break;
		}
	}
	mwfile.close();
	return res;
}

void MalwareList::add(const std::string& guid, const std::string& hextrace)
{
	size_t l = hextrace.length() / 2;
	std::unique_ptr<uint8_t[]> p_buf(new uint8_t[l]);
	int sl = hex2raw(hextrace, p_buf.get(), (int)l);

	std::vector<uint8_t> trace(p_buf.get(), p_buf.get() + l);
	std::vector<int> suffshift = BMSeeker::compute_suffshift(p_buf.get(), sl);

	m_box.push_back(SeekData{ suffshift, trace, guid });
}

const SeekData MalwareList::operator[](size_t pos) const
{
	if (m_box.empty() || pos > m_box.size() - 1)
		return SeekData();

	return m_box[pos];
}

size_t MalwareList::size() const
{
	return m_box.size();
}

